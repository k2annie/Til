# 4-4. 

## CURRENT_DATETIME([time_zone]) : 현재 DATETIME 출력

SELECT
 CURRENT_DATE() AS current_date, // 타임존이 없는 것과

 CURRENT_DATE("Asia/Seoul") AS asia_date, // 있는 것.

 CURRENT_DATETIME() AS current_datetime,

 CURRENT_DATETIME("Asia/Seoul") AS current_datetime_asia;

## EXTRACT
: DATETIME에서 특정 부분만 추출하고 싶은 경우

요일을 추출하고 싶은 경우
```EXTRACT(DAYOFWEEK FROM datetime_col)```
- 한 주의 첫날이 일요일인 [1, 7] 범위의 값을 반환

## DATETIME_TRUNC 
- 원하는 데이터까지만 불러오고 나머지는 다 버린다는 메타.
- hour_trunc 를 가장 많이 사용할 듯~!

## PARSE_DATETIME
: 문자열로 저장된 DATETIME을 DATETIME 타입으로 바꾸고 싶은 경우.

```PARSE_DATETIME('문자열의 형태', 'DATETIME 문자열') AS datetime```
```
ex. 
SELECT
 PARSE_DATETIME('%Y-%m-%d %H:%M:%S', '2024-01-11 12:35:35') AS parse_datetime;
```
파싱하다 : 문자열 데이터를 분석하여 알맞은 것으로 배치한다.

## FORMAT_DATETIME
: DATETIME 타입 데이터를 특정 형태의 문자열 데이터로 변환하고 싶은 경우.

### 정리
```
=> 문자열 -> DATETIME : PARSE_DATETIME
     DATETIME -> 문자열 : FORMAT_DATETIME
```
### LAST_DAY
마지막 날을 알고 싶은 경우 : 자동으로 월의 마지막 값을 계산해서 특정 연산을 할 경우
```LAST_DAY(DATETIME) : 월의 마지막 값을 반환```

## DATETIME_DIFF
: 두 DATETIME의 차이를 알고 싶은 경우

```DATETIME_DIFF(첫 DATETIME, 두번째 DATETIME, 궁금한 차이)```

-> 궁금한 차이 : DAY/MONTH/WEEK , 보통 큰 값을 앞에 배치.


# 4-5. 연습문제

## 1. 트레이너가 포켓몬을 포획한 날짜(catch_date)를 기준으로, 2023년 1월에 포획한 포켓몬의 수를 계산해주세요.

 - 쿼리를 작성하는 목표, 확인할 지표 : 포켓몬의 수
 - 쿼리 계산 방법 : COUNT
 - 데이터의 기간 : 2023년 1월
 - 사용할 테이블 : trainer_pokemon
 - Join KEY : X 
 - 데이터 특징 : 직접 봐야함!
 ```
	-- catch_date : DATE 타입
	-- catch_datetime : UTC. TIMESTAMP 타입 => 컬럼의 이름은 	datetime인데 TIMESTAMP 타입으로 저장되어 있다.
	-----> datetime이면 뒤에 UTC가 붙지않고 중간에 T 붙은 식.
	-- catch_date에 대한 직접적인 명시X -> KR 기준/ UTC 기준 쳌!
	-- catch_date 컬럼과 catch_datetime 컬럼을 비교 => 	DATE(DATETIME(catch_datetime, "Asia/Seoul"))
	-- catch_date != DATE(DATETIME(catch_datetime, "Asia/Seoul")) 	
    => 있다면 catch_date의 사용은 힘들 수 있다.
```
```
SELECT
COUNT(*)
FROM(

SELECT
id,
catch_date,
DATE(DATETIME(catch_datetime, "Asia/Seoul")) As catch_datetime_kr_date
FROM basic.trainer_pokemon
)

WHERE
catch_date != catch_datetime_kr_date


SELECT
COUNT(DISTINCT id) AS cnt
FROM basic.trainer_pokemon
WHERE
 EXTRACT(YEAR FROM_DATETIME(catch_datetime, "Asia/Seoul")) = 2023
# catch_datetime은 TIMESTAMP로 저장되어 있으므로, DATETIME으로 변경해야 함.

AND EXTRACT(MONTH FROM_DATETIME(catch_datetime, "Asia/Seoul")) =1
```
### 문제 출제 의도 : 요청한 사람 또는 문제를 그대로 볼 경우 틀릴 수 있으니 컬럼을 꼭! 파악하고(정의 확인) 쿼리를 작성하자!


## 2. 배틀이 일어난 시간(battle_datetime)을 기준으로, 오전 6시에서 오후 6시에 일어나 배틀의 수를 계산해주세요.

- 쿼리를 작성하는 목표, 확인할 지표 : 오전 6시-오후 6시 배틀의 수
- 쿼리 계산 방법 : COUNT
- 데이터의 기간 : 일자는 상관없고, 오전 6시-오후 6시
- 사용할 테이블 : battle
- Join KEY : X 
- 데이터 특징 : 직접 봐야함!
```
-- battle_date : battle_datetime을 기반으로 만들어진 DATE
-- battle_datetime : DATETIME
-- battle_datetime이랑 DATETIME(battle_timestamp, "Asia/Seoul") 같은지 확인! -> countif 쿼리 이용해서 확실히 확인해주기!
```
```
SELECT
id,
battle_datetime,
DATETIME(battle_timestamp, "Asia/Seoul") AS battle_timestamp_kr,
COUNTIF(battle_datetime = DATETIME(battle_timestamp, "Asia/Seoul")) AS battle_datetime_same_battle_timestamp_kr
/*
COUNTIF(battle_datetime != DATETIME(battle_timestamp, "Asia/Seoul")) AS battle_datetime_not_same_battle_timestamp_kr
*/
FROM basic.battle
```
### sol1
```
SELECT
COUNT(DISTINCT id) AS battle_cnt
FROM basic.battle
WHERE
EXTRACT(HOUR FROM battle_datetime) >=6
AND EXTRACT(HOUR FROM battle_datetime) <18
```
### sol2 - extract가 너무 반복되니까 'between' 사용해서 표현.(시간이니까~)
```
/*
EXTRACT(HOUR FROM battle_datetime) >=6
AND EXTRACT(HOUR FROM battle_datetime) <18
*/
해당 코드 대신에
EXTRACT(HOUR FROM battle_datetime) BETWEEN 6 and 18
```

### 시간대별로 몇 건이 있는가?
```
SELECT
hour,
COUNT(DISTINCT id) AS battle_cnt
FROM (

SELECT
*,
EXTRACT(HOUR FROM battle_datetime) AS hour
FROM basic.battle
)

GROUP BY
hour
ORDER BY
hour
```